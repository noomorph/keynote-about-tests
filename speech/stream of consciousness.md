Многие привыкли к четкому разделению труда между программистами и automation QA — юнит и end-to-end.

Во многих проектах тестов по-немножку: либо нет, либо мало, либо тяжело для понимания написаны и так далее.

Вам дали большой старый проект или подпроект не самым понятным кодом, по которому и обратиться не к кому. И нужно вам сделать новую фичу, или совершить непростой багфикс, который может затронуть нехилую часть системы.

В большинстве случаев, я не считаю правильным то самое простое решение — чик-чик, в тестирование, чик-чик багфиксы, в тестирование, чик-чик багфиксы-багфиксы.

Если проект довольно стар или вообще на суппорте, я лично сталкивался что на количестве QA-времени любят экономить. Сложно ожидать, что будет проводен хороший regression.

Важно понять, что говоря “automation — это не по моей части”, вы немного лукавите. Конечно же, те ребята, кто на этом серьезно специализируются, превзойдут вас и в чистоте кода, и в эффективности написания, и на первых порах это довольно сложный процесс для начинания.

Но сам этот факт не должен вас останавливать.

Во-первых, с чего-то все равно нужно начинать, и не боги горшки обжигали. 
Во-вторых, не ошибается тот, кто ничего не делает. Если написанные тесты — полное дерьмо, то их всегда можно переписать или удалить.
В-третьих, можно выбирать тот вариант, который вам кажется наиболее удачным по вложению сил и времени: от букмарклетов до автоматизации браузеров в кластере.

У вас будет вопрос: а сколько же времени займет написать более-менее покрывающий набор тестов? Ну и вообще, пока вы напишите там свой набор, два раза можно было бы потестить руками и еще перефиксить код.

Первый шаги:

Пронаблюдайте за собой с точки зрения JS.
Вот гружу документ:
Вот кликаю этот елемент: ```document.querySelector(“nav li:nth-child(1)”).click();```
Вот ждем пока появится диалог. Да, тут чуть сложнее, но об этом чуть позже.
```
dialog = document.querySelector(“.modal-dialog”);
```
Смотрим в диалоге, какие поля заполнены:
```
dialog.querySelector(“input[name=firstName]”).value == “John”
dialog.querySelector(“input[name=lastName]”).value == “Smith”
dialog.querySelector(“input[name=age]”).value == 36
dialog.querySelector(“input[name=agree]”).checked === true
```
Ну да, код потихоньку начинает напоминать простыню.

Не стесняйтесь юзать разные вспомогательные библиотеки (вредно думать в тестах о различии между браузерами) jQuery/Zepto/MooTools/whatever, Underscore/Lodash.

Для этого используют паттерн PageObject:

```
function Dialog(container) {
    this.container = container;
}

Dialog.prototype.elements = {
   btnClose: function () {
       return $(this.container).find(“a.btn-close”);
   },
   firstName: function () {
       return $(this.container).find(“input[name=firstName]”);
   }
};

Dialog.prototype.close = function () {
   this.elements.btnClose().click();
};
```

Это может вам дать 5-30 секунд на каждом прохождении, и потребовать меньше концентрации при проверке на разных браузерах.

Этот подход хорошо может отрабатывать на single page applications, но не подходит для — на pure MVC или что еще веселее ASP.NET с postbacks.

Теперь о более извращенных методах, и что мы можем еще выжать из этого.

Делаем букмарклет с Mocha, Jasmine или чем-то подобным. И пусть прогружаются тесты в консоль.

Здесь можно хорошо провернуть штучку с async-колбеком .done().

Круче всего 1 expect - 1 spec, чтобы вы знали где конкретно падает, сходу.

Важно, чтобы ваши тесты минимально полагались на знание API и функций ваших классов, хотя есть моменты, когда без этого не обойтись. Или очень сложные UI-действия, которые легче руками глянуть (решаемо), или же взаимодействие c iframe/веб-сервисами, где тоже все сложно.

Почему я об этом вообще говорю?

Мне кажется, что почти в любой компании есть либо файл, либо папка, либо подпроект, либо проекты, которые написаны давно и “несахар”. Нет тестов или три теста на 1000 строк кода. Автор может работать уже в другом месте, и вообще имеет право не помнить “а что оно и как”.

В то же время, этот код могли несколько раз исправлять и дополнять “по-шурику” в разное время и разные люди — в итоге имеем какие-то workarounds внутри файлов, и что еще веселее — bugs/workarounds by design, т.е. другие классы начинают полагаться на недокументированные багофичи. И это почти всегда неожиданный “сюрпрайз” при правке кода. :)

С другой стороны, у нас ограниченный бюджет/время и переделать возможности нет. Так что нам выпала счастливая участь что-то добавить в код, который не менялся несколько лет, и который никто не помнит. Постараемся же сохранить backward compatibility.

Если вы спросите, а в чем профит? Стало ли у меня в среднем меньше багов — скажу прямо, что нет. Все равно делаю “новые!” баги. Но на тот момент мне это спасло 2-3 часа времени, посколько мне не нужно было перепроверять фичи по многу раз после каждого изменения. Что уже неплохо.

Это не серебрянная пуля.

Как фронт-ендщику тебе надо еще работать не только с данными и логикой приложения, но и стилями и логикой представления. Часто, работая над сайтом, можно увидеть CSS стили неудоволетворительного качества. Руки чешутся это подправить, но на другую чашу весов мы часто кладем еще и риск, что что-то сломаем в отображении. Значительно уменьшить этот риск нам поможет тестирование внешнего вида.

Существуют, как минимум, два подхода. Один — базируется на логическом представлении расположении элементов относительно друг друга (все кнопки меню над текстом, расположены горизонтально, имеют такой и такой текст). Другой — базируется на скриншотах. Сначала сканируется сайт, делаются скриншоты baseline как образец. Все дальнейшие изменения рендерятся в скриншоты и сравниваются с baseline.

Мой сайт я автоматизировал на CSS-регрессии буквально за вечер, 2 часа.

Используется связка CasperJS + PhatomCSS (интегрированы два движка: PhantomJS — Chrome, SlimerJS — Firefox). Кроме движков, настраиваются еще и viewports с разными разрешениями.

Теперь перейдем к тому, что я бы назвал тяжелой артиллерией. Здесь требуются большие инвестиции времени на первых порах.

WebdriverJS или обертки, CasperJS.

Про юнит-тесты — в легаси-проектах это очень тяжело, и кушает много усилий. Начинать лучше с integration, потому что если вы с какой-то частью проекта не работали, то вы даже не знаете, что вы конкретно напишите. У меня такой случай был — при вливании в новый проект мне досталась комплексная задача, требующая хорошего знания системы. Около пяти раз я переписывал свой код, и поэтому 4 раза юнит-тесты пришлось бы просто стереть.
